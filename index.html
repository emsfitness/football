<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>Ù…Ø§ØªØ´ ÙƒÙˆØ±Ø© Ø¨ÙŠÙ† Ù„Ø§Ø¹Ø¨ÙŠÙ†</title>
  <style>
    body { font-family: Arial; text-align: center; background: #d0f0ff; margin: 0; padding: 0; }
    .screen { display: none; padding: 20px; }
    .active { display: block; }
    #playersList { margin-top: 10px; }
    .player { background: #fff; padding: 10px; margin: 5px auto; width: 200px; border-radius: 5px; }
    #field {
      width: 80vw; height: 60vh; background: green; margin: 20px auto; position: relative; border: 4px solid #fff;
      background-image: 
        linear-gradient(90deg, white 2px, transparent 2px),
        radial-gradient(circle at 50% 50%, transparent 20%, white 21%, white 22%, transparent 23%);
      background-size: 50px 100%, 30% 30%;
      background-position: center;
      background-repeat: no-repeat;
    }
    .ball, .player-icon {
      width: 30px; height: 30px; position: absolute; border-radius: 50%;
      text-align: center; line-height: 30px; font-weight: bold; color: white;
    }
    .ball { background: orange; transform: translate(-50%, -50%); z-index: 10; }
    .player-icon { background: blue; }
    .goal { position: absolute; width: 10%; height: 20%; background: red; opacity: 0.5; }
    .goal.left { left: 0; top: 40%; }
    .goal.right { right: 0; top: 40%; }
    #scoreBoard { font-size: 20px; margin: 10px; }
    #timer { font-size: 18px; }
    button { padding: 10px 20px; font-size: 16px; margin-top: 10px; }
    #messageArea { margin-top: 20px; font-size: 18px; color: red; display: none; }
  </style>
</head>
<body>

  <!-- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ -->
  <div id="loginScreen" class="screen active">
    <h2>Ø£Ø¯Ø®Ù„ Ø§Ø³Ù…Ùƒ Ù„Ù„Ø§Ù†Ø¶Ù…Ø§Ù…:</h2>
    <input type="text" id="playerName" placeholder="Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨">
    <button onclick="joinGame()">Ø§Ù†Ø¶Ù…</button>
  </div>

  <!-- ØºØ±ÙØ© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± -->
  <div id="waitingRoom" class="screen">
    <h2>ØºØ±ÙØ© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±</h2>
    <div id="playersList"></div>
    <button onclick="startGame()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©</button>
  </div>

  <!-- Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© -->
  <div id="gameField" class="screen">
    <h2>ğŸŸï¸ Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©</h2>
    <div id="scoreBoard">Ø§Ù„Ù†ØªÙŠØ¬Ø©: <span id="scoreA">0</span> - <span id="scoreB">0</span></div>
    <div id="timer">Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <span id="timeLeft">10:00</span></div>
    <div id="field">
      <div class="goal left"></div>
      <div class="goal right"></div>
      <div class="ball" id="ball">âš½</div>
    </div>
    <button onclick="resetGame()">ğŸ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©</button>
    <div id="messageArea"></div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDUFdNboswpWIs0I5ry4aJs3aXHlg1CKkM",
      authDomain: "match-9d433.firebaseapp.com",
      projectId: "match-9d433",
      storageBucket: "match-9d433.firebasestorage.app",
      messagingSenderId: "1050352234947",
      appId: "1:1050352234947:web:74aa21731ea3b94637cd76",
      measurementId: "G-59QRBNR1WQ",
      databaseURL: "https://match-9d433-default-rtdb.firebaseio.com"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    const matchId = new URLSearchParams(location.search).get("match") || "defaultMatch";
    const playersRef = db.ref(`${matchId}/players`);
    const gameStartedRef = db.ref(`${matchId}/gameStarted`);
    const scoreRef = db.ref(`${matchId}/score`);
    const ballRef = db.ref(`${matchId}/ball`);
    const timeRef = db.ref(`${matchId}/time`);
    const ballVelocityRef = db.ref(`${matchId}/ballVelocity`);

    let currentPlayer = "";
    let isHost = false;
    let timerInterval;
    let gameDuration = 600;
    let gameStarted = false;
    let lastPlayerHit = null;

    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }

    function showMessage(msg, duration = 2000) {
      const area = document.getElementById("messageArea");
      area.textContent = msg;
      area.style.display = "block";
      setTimeout(() => {
        area.style.display = "none";
      }, duration);
    }

    function joinGame() {
      const name = document.getElementById('playerName').value.trim();
      if (!name) return alert("Ø§ÙƒØªØ¨ Ø§Ø³Ù…Ùƒ!");

      currentPlayer = name;
      const playerRef = playersRef.child(name);

      playerRef.set({
        name: name,
        x: 50,
        y: 50,
        joinedAt: Date.now()
      });

      playersRef.once("value").then(snapshot => {
        const players = snapshot.val();
        const playerNames = Object.keys(players || {});
        if (playerNames.length === 1 || playerNames[0] === name) isHost = true;
      });

      gameStartedRef.once("value").then(snap => {
        if (snap.val()) {
          alert("Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø¨Ø¯Ø£Øª Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø§Ù„Ø¢Ù†.");
          return;
        } else {
          showScreen("waitingRoom");
        }
      });
    }

    function updateWaitingRoom(players) {
      const list = document.getElementById("playersList");
      list.innerHTML = "";
      Object.values(players).forEach(p => {
        const div = document.createElement("div");
        div.className = "player";
        div.textContent = p.name;
        list.appendChild(div);
      });
    }

    function startGame() {
      if (!isHost) return alert("ÙÙ‚Ø· Ù…Ù† Ø¨Ø¯Ø£ Ø§Ù„ØºØ±ÙØ© ÙŠÙ…ÙƒÙ†Ù‡ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©!");
      db.ref(matchId).update({
        gameStarted: true,
        ball: { x: 50, y: 50 },
        ballVelocity: { x: 0, y: 0 },
        score: { A: 0, B: 0 },
        time: gameDuration
      });
    }

    function updateTimer(seconds) {
      const m = String(Math.floor(seconds / 60)).padStart(2, '0');
      const s = String(seconds % 60).padStart(2, '0');
      document.getElementById("timeLeft").textContent = `${m}:${s}`;
    }

    function startCountdown() {
      timerInterval = setInterval(() => {
        timeRef.once("value").then(snap => {
          let t = snap.val();
          if (t <= 0) {
            clearInterval(timerInterval);
            showMessage("Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©!");
            return;
          }
          timeRef.set(t - 1);
        });
      }, 1000);
    }

    function renderPlayers(players) {
      const field = document.getElementById("field");
      field.querySelectorAll(".player-icon").forEach(p => p.remove());
      Object.values(players).forEach((p, i) => {
        const el = document.createElement("div");
        el.className = "player-icon";
        el.textContent = i + 1;
        el.style.left = p.x + "%";
        el.style.top = p.y + "%";
        field.appendChild(el);
      });
    }

    function updateBallPosition() {
      ballRef.once("value").then(ballSnap => {
        ballVelocityRef.once("value").then(velSnap => {
          const ball = ballSnap.val();
          const velocity = velSnap.val() || { x: 0, y: 0 };
          
          if (!ball) return;
          
          // Apply friction to slow down the ball (increased friction to weaken movement)
          const friction = 0.92; // Increased from 0.98 to make the ball stop faster
          let newVx = velocity.x * friction;
          let newVy = velocity.y * friction;
          
          // Stop the ball if velocity is very small
          if (Math.abs(newVx) < 0.05) newVx = 0;
          if (Math.abs(newVy) < 0.05) newVy = 0;
          
          // Calculate new position with boundary checks
          let newBallX = ball.x + newVx;
          let newBallY = ball.y + newVy;
          
          // Prevent ball from getting stuck at boundaries
          const buffer = 0.5; // Small buffer to keep ball inside field
          if (newBallX <= buffer) newBallX = buffer;
          if (newBallX >= 100 - buffer) newBallX = 100 - buffer;
          if (newBallY <= buffer) newBallY = buffer;
          if (newBallY >= 100 - buffer) newBallY = 100 - buffer;
          
          // If ball hits boundary, reverse direction with reduced force
          if (newBallX <= buffer || newBallX >= 100 - buffer) {
            newVx = -newVx * 0.5; // Reduce bounce force
          }
          if (newBallY <= buffer || newBallY >= 100 - buffer) {
            newVy = -newVy * 0.5; // Reduce bounce force
          }
          
          ballRef.set({ x: newBallX, y: newBallY });
          ballVelocityRef.set({ x: newVx, y: newVy });
          
          // Check for goals
          if (newBallX < 5 && newBallY > 40 && newBallY < 60) {
            scoreRef.child("A").transaction(v => (v || 0) + 1);
            showMessage("Ù‡Ø¯Ù Ù„Ù„ÙØ±ÙŠÙ‚ A");
            resetPositions();
          }
          if (newBallX > 95 && newBallY > 40 && newBallY < 60) {
            scoreRef.child("B").transaction(v => (v || 0) + 1);
            showMessage("Ù‡Ø¯Ù Ù„Ù„ÙØ±ÙŠÙ‚ B");
            resetPositions();
          }
        });
      });
    }

    function resetPositions() {
      playersRef.once("value").then(snap => {
        const updates = {};
        Object.keys(snap.val() || {}).forEach(name => {
          updates[`${matchId}/players/${name}/x`] = 50;
          updates[`${matchId}/players/${name}/y`] = 50;
        });
        updates[`${matchId}/ball`] = { x: 50, y: 50 };
        updates[`${matchId}/ballVelocity`] = { x: 0, y: 0 };
        db.ref().update(updates);
      });
    }

    function renderScore(score) {
      document.getElementById("scoreA").textContent = score.A || 0;
      document.getElementById("scoreB").textContent = score.B || 0;
    }

    function resetGame() {
      db.ref(matchId).set({});
      location.reload();
    }

    function handleBallCollision(playerX, playerY, ballX, ballY, playerName) {
      const dx = ballX - playerX;
      const dy = ballY - playerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 5) {
        // Prevent the same player from hitting the ball multiple times in quick succession
        if (lastPlayerHit === playerName) return;
        lastPlayerHit = playerName;
        setTimeout(() => { lastPlayerHit = null; }, 500);
        
        // Calculate new velocity based on player-ball vector (reduced power)
        const power = 1.5; // Reduced from 3 to make the ball move less distance
        const newVx = (dx / distance) * power;
        const newVy = (dy / distance) * power;
        
        ballVelocityRef.set({ x: newVx, y: newVy });
      }
    }

    playersRef.on("value", snapshot => {
      const players = snapshot.val() || {};
      updateWaitingRoom(players);
      renderPlayers(players);
    });

    gameStartedRef.on("value", snapshot => {
      gameStarted = snapshot.val();
      if (gameStarted) {
        showScreen("gameField");
        startCountdown();
        // Update ball position continuously
        setInterval(updateBallPosition, 50);
      }
    });

    ballRef.on("value", snapshot => {
      const ball = snapshot.val();
      if (ball) {
        const ballEl = document.getElementById("ball");
        ballEl.style.left = ball.x + "%";
        ballEl.style.top = ball.y + "%";
      }
    });

    scoreRef.on("value", snapshot => {
      const score = snapshot.val() || { A: 0, B: 0 };
      renderScore(score);
    });

    timeRef.on("value", snapshot => {
      updateTimer(snapshot.val() || 0);
    });

    document.addEventListener("keydown", (e) => {
      if (!currentPlayer || !gameStarted) return;
      const allowed = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
      if (!allowed.includes(e.key)) return;

      const playerRef = playersRef.child(currentPlayer);
      playerRef.once("value").then((snap) => {
        let data = snap.val();
        if (!data) return;

        let x = data.x;
        let y = data.y;
        const step = 2;

        if (e.key === "ArrowUp") y = Math.max(0, y - step);
        if (e.key === "ArrowDown") y = Math.min(100, y + step);
        if (e.key === "ArrowLeft") x = Math.max(0, x - step);
        if (e.key === "ArrowRight") x = Math.min(100, x + step);

        playerRef.update({ x, y });

        ballRef.once("value").then(bSnap => {
          const ball = bSnap.val();
          if (!ball) return;
          
          handleBallCollision(x, y, ball.x, ball.y, currentPlayer);
        });
      });
    });
  </script>
</body>
</html>
